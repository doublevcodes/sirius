import re
import sys
import typing as t
from collections import defaultdict
from collections.abc import MutableMapping
from pathlib import Path

import atoml
from attr import fields_dict

from sirius.config.config import Cfg, ConfigurationSchema


class DidFileEdit:
    """Check if a file is edited within the body of this class."""

    def __init__(self, *files: Path):
        self.files: t.List[Path] = []
        for f in files:
            self.files.append(f)
        self.return_value: t.Optional[int] = None
        self.edited_files: t.List[Path] = []

    def __enter__(self):
        self.file_contents = {}
        for file in self.files:
            try:
                with open(file, "r") as f:
                    self.file_contents[file] = f.read()
            except FileNotFoundError:
                self.file_contents[file] = None

    def __exit__(self, exc_type, exc_value, exc_traceback):  # noqa: ANN001
        for file in self.files:
            with open(file, "r") as f:
                contents = self.file_contents[file]
                if contents != f.read():
                    self.edited_files.append(file)


def flatten(d: dict, parent_key: str = "", sep: str = ".") -> dict:
    """Flatten a `dict` object."""
    items = []

    for k, v in d.items():
        new_key = parent_key + sep + k if parent_key else k
        if isinstance(v, MutableMapping):
            items.extend(flatten(v, new_key, sep=sep).items())
        else:
            items.append((new_key, v))

    return dict(items)


def unflatten(d: dict, sep: str = ".") -> defaultdict:
    """Unflatten a `dict` object."""
    ret = defaultdict(dict)
    for k, v in d.items():
        k1, delim, k2 = k.partition(sep)
        if delim:
            ret[k1].update({k2: v})
        else:
            ret[k1] = v
    return ret


def add_comment(string: str) -> str:
    """Make the config key a comment key by prefixing it with `comment_`."""
    li = string.split(".")
    li[-1] = f"comment_{li[-1]}"
    return ".".join(li)


def merge_dicts(metadata_dict: dict, dump_dict: dict) -> defaultdict:
    """Merge metadata and dump dict, return the unflattened version of the merged dict."""
    metadata_dict = list(metadata_dict.items())
    metadata_dict = [(add_comment(key), description) for key, description in metadata_dict]

    dump_dict = list(dump_dict.items())
    result = sum(zip(metadata_dict, dump_dict + [0]), ())
    result = {x[0]: x[1] for x in result}
    return unflatten(result)


def export_default_config(file) -> bool:
    """Export default configuration as both toml and yaml to the preconfigured locations."""
    default = Cfg()
    dump: dict = ConfigurationSchema().dump(default)

    flattened_dump = flatten(dump)
    cfg = fields_dict(Cfg)  # noqa: F841
    metadata = {}

    for config_key in flattened_dump.keys():
        keys = config_key.split(".")
        last_index = len(keys) - 1
        field = "fields_dict(cfg[keys[0]].type)"

        for index, _ in enumerate(keys[1:], start=1):
            if index == last_index:
                field = f"{field}[keys[{index}]].metadata['config_metadata'].description"
            else:
                field = f"fields_dict({field}[keys[{index}]].type)"

        metadata[config_key] = eval(field)  # noqa: S307

    dump = dict(merge_dicts(metadata, flattened_dump))

    doc = atoml.document()
    doc.add(atoml.comment("This is an autogenerated TOML document."))
    doc.add(atoml.nl())

    doc.update(dump)

    # create parent config, anyone of them is fine as they have the same parent
    file.parent.mkdir(exist_ok=True)

    check_file = DidFileEdit(file)

    with check_file:
        with open(file, "w") as f:
            toml_dump = atoml.dumps(doc)
            toml_dump = re.sub(r"(comment_\w+ = \"(.*)\")", r"# \2", toml_dump, 0, re.MULTILINE)
            f.write(toml_dump)

    for file in check_file.edited_files:
        print(
            f"Exported new configuration to {Path(file)}.",
            file=sys.stderr,
        )
    return bool(len(check_file.edited_files))
