import re
import sys
import typing as t
from collections import OrderedDict
from pathlib import Path

import atoml
from attr import fields_dict

from sirius.config.config import Cfg, ConfigurationSchema


class DidFileEdit:
    """Check if a file is edited within the body of this class."""

    def __init__(self, *files: Path):
        self.files: t.List[Path] = []
        for f in files:
            self.files.append(f)
        self.return_value: t.Optional[int] = None
        self.edited_files: t.List[Path] = []

    def __enter__(self):
        self.file_contents = {}
        for file in self.files:
            try:
                with open(file, "r") as f:
                    self.file_contents[file] = f.read()
            except FileNotFoundError:
                self.file_contents[file] = None

    def __exit__(self, exc_type, exc_value, exc_traceback):  # noqa: ANN001
        for file in self.files:
            with open(file, "r") as f:
                contents = self.file_contents[file]
                if contents != f.read():
                    self.edited_files.append(file)


def flatten(dictionary: dict, parent_key: str = "", sep: str = ".") -> dict:
    """Flatten a `dict` object."""
    items = []

    for k, v in dictionary.items():
        new_key = parent_key + sep + k if parent_key else k
        if isinstance(v, dict):
            items.extend(flatten(v, new_key, sep=sep).items())
        else:
            items.append((new_key, v))

    return dict(items)


def unflatten(dictionary: dict) -> dict:
    """Unflatten a `dict` object which was flattened by the above function."""
    ret = dict()

    for key, value in dictionary.items():
        parts = key.split(".")
        d = ret
        for part in parts[:-1]:
            if part not in d:
                d[part] = dict()
            d = d[part]
        d[parts[-1]] = value

    return ret


def commentify_metadata(metadata: dict) -> dict:
    """Make the config key a comment key by prefixing it with `comment_`."""
    ret = {}
    for key, value in metadata.items():
        if isinstance(value, dict):
            value = commentify_metadata(value)
        else:
            key = f"comment_{key}"

        ret[key] = value

    return ret


def merge_copy(metadata, dump) -> OrderedDict:
    ret = OrderedDict()

    for key, value in dump.items():
        if isinstance(value, dict):
            ret[key] = merge_copy(metadata[key], dump[key])
        else:
            ret[f"comment_{key}"] = metadata[f"comment_{key}"]
            ret[key] = value

    return ret


def export_default_config(file) -> bool:
    """Export default configuration as both toml and yaml to the preconfigured locations."""
    default = Cfg()
    dump: dict = ConfigurationSchema().dump(default)

    flattened_dump = flatten(dump)
    cfg = fields_dict(Cfg)  # noqa: F841
    metadata = {}

    for config_key in flattened_dump.keys():
        keys = config_key.split(".")
        last_index = len(keys) - 1
        field = "fields_dict(cfg[keys[0]].type)"

        for index, _ in enumerate(keys[1:], start=1):
            if index == last_index:
                field = (
                    f"{field}[keys[{index}]].metadata['config_metadata'].description"
                )
            else:
                field = f"fields_dict({field}[keys[{index}]].type)"

        metadata[config_key] = eval(field)  # noqa: S307

    metadata = commentify_metadata(unflatten(metadata))
    dump = merge_copy(metadata, dump)

    doc = atoml.document()
    doc.add(atoml.comment("This is an autogenerated TOML document."))
    doc.add(atoml.nl())

    doc.update(dump)

    # create parent config, anyone of them is fine as they have the same parent
    file.parent.mkdir(exist_ok=True)

    check_file = DidFileEdit(file)

    with check_file:
        with open(file, "w") as f:
            toml_dump = atoml.dumps(doc)
            toml_dump = re.sub(
                r"(comment_\w+ = \"(.*)\")", r"# \2", toml_dump, 0, re.MULTILINE
            )
            f.write(toml_dump)

    for file in check_file.edited_files:
        print(
            f"Exported new configuration to {Path(file)}.",
            file=sys.stderr,
        )
    return bool(len(check_file.edited_files))
