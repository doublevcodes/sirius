{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sirius Create APIs that shine like a star Sirius, commonly known as the brightest star in the night sky, is also an API framework written with ease-of-use and developer experience in mind. By learning from frameworks written not only in Python, but other languages too, Sirius provides a set of distinctive features aiming to provide the best possible experience developing a dazzling application on a starry night. Key features Sirius aims to take developer experience to the next level and so it provides a set of features aiming to provide a developer with little to no headaches! Some of these include, but aren't limited to: File-based routing : Perhaps what sets Sirius apart from the rest, this allows the developer to watch their API grow - inside a directory! A zero-boilerplate experience : With this, all one has to do is pip install sirius-api , and the rest will be done for you. Simple applications don't even need to import Sirius! A CLI utility : Don't want to programmatically be running Sirius with calls to the framework? Easy, open a terminal and sirius dev will do the job for you. Requirements Sirius aims to be next-generation and so currently only supports Python 3.10 . Backwards compatibility to older Python versions may be introduced at a later date. You don't need to install any external packages to run a Sirius application... apart from Sirius Installation Simple: Pip Pipenv Poetry $ pip install sirius-api $ pipenv install sirius-api $ poetry add sirius-api ...and you're ready to dive into an astronomical world of fun! Example Build it A simple Sirius API that defines a root endpoint ( / ) that responds to GET requests with a message would look like the following: def get (): return \"Astronomically amazing!\" Where does this go in my project? The file this would be found in relative to your project would be ./routes/__init__.py . as you'll soon lean, a file named __init__.py in Sirius represents a root endpoint. Keep flying! You're nearly there! Run it Now that you've defined what your API should do, we need to run it! So open up a terminal and run sirius dev . This should start up a development server that uses Uvicorn on port 8000, so have a look at http://localhost:8000 . Depending on your browser, you should see some variation of the text: Astronomically amazing! You've made a complete Sirius app! Recommended resources HTTP Client As you progress further in your API development adventure, it would be suggested to not rely on your browser for testing them. Instead, HTTPie , which is a HTTP client for the CLI with a desktop app and website currently in beta, is recommended. It provides easy-to-remember syntax and is very powerful. A simple DELETE request to http://localhost:8000/foo , using sirius as the lib query parameter can be represented as $ http DELETE :8000/foo sirius == lib Yes: it's that easy! REST Architecture The MDN Web Developer Documentation explains REST concepts in extreme detail. Here you can find detail information on HTTP verbs and HTTP status codes. Have a good read! Have fun developing with Sirius!","title":"Sirius"},{"location":"#sirius","text":"Create APIs that shine like a star Sirius, commonly known as the brightest star in the night sky, is also an API framework written with ease-of-use and developer experience in mind. By learning from frameworks written not only in Python, but other languages too, Sirius provides a set of distinctive features aiming to provide the best possible experience developing a dazzling application on a starry night.","title":"Sirius"},{"location":"#key-features","text":"Sirius aims to take developer experience to the next level and so it provides a set of features aiming to provide a developer with little to no headaches! Some of these include, but aren't limited to: File-based routing : Perhaps what sets Sirius apart from the rest, this allows the developer to watch their API grow - inside a directory! A zero-boilerplate experience : With this, all one has to do is pip install sirius-api , and the rest will be done for you. Simple applications don't even need to import Sirius! A CLI utility : Don't want to programmatically be running Sirius with calls to the framework? Easy, open a terminal and sirius dev will do the job for you.","title":"Key features"},{"location":"#requirements","text":"Sirius aims to be next-generation and so currently only supports Python 3.10 . Backwards compatibility to older Python versions may be introduced at a later date. You don't need to install any external packages to run a Sirius application... apart from Sirius","title":"Requirements"},{"location":"#installation","text":"Simple: Pip Pipenv Poetry $ pip install sirius-api $ pipenv install sirius-api $ poetry add sirius-api ...and you're ready to dive into an astronomical world of fun!","title":"Installation"},{"location":"#example","text":"","title":"Example"},{"location":"#build-it","text":"A simple Sirius API that defines a root endpoint ( / ) that responds to GET requests with a message would look like the following: def get (): return \"Astronomically amazing!\" Where does this go in my project? The file this would be found in relative to your project would be ./routes/__init__.py . as you'll soon lean, a file named __init__.py in Sirius represents a root endpoint. Keep flying! You're nearly there!","title":"Build it"},{"location":"#run-it","text":"Now that you've defined what your API should do, we need to run it! So open up a terminal and run sirius dev . This should start up a development server that uses Uvicorn on port 8000, so have a look at http://localhost:8000 . Depending on your browser, you should see some variation of the text: Astronomically amazing! You've made a complete Sirius app!","title":"Run it"},{"location":"#recommended-resources","text":"","title":"Recommended resources"},{"location":"#http-client","text":"As you progress further in your API development adventure, it would be suggested to not rely on your browser for testing them. Instead, HTTPie , which is a HTTP client for the CLI with a desktop app and website currently in beta, is recommended. It provides easy-to-remember syntax and is very powerful. A simple DELETE request to http://localhost:8000/foo , using sirius as the lib query parameter can be represented as $ http DELETE :8000/foo sirius == lib Yes: it's that easy!","title":"HTTP Client"},{"location":"#rest-architecture","text":"The MDN Web Developer Documentation explains REST concepts in extreme detail. Here you can find detail information on HTTP verbs and HTTP status codes. Have a good read! Have fun developing with Sirius!","title":"REST Architecture"},{"location":"Tutorial/requests/","text":"Receiving requests Perhaps the most important part of any API is the ability to receive requests and carry out a certain function based on the characteristics of this request. For a simple REST API, at a high level, two things define what happens to a request. Need a refresher on HTTP methods? Check out this resource The request endpoint The HTTP request method Sirius has ways to manage both of these with such ease. It seems logical to begin with endpoints, since HTTP methods form a subset of operations upon each endpoint. Endpoints An endpoint in a Sirius API is represented by a Python file in a certain directory. By default this magical directory is src/routes . The following directory structure: src/ \u2514\u2500 routes/ \u251c\u2500 __init__.py \u251c\u2500 baz.py \u2514\u2500 foo/ \u251c\u2500 __init__.py \u2514\u2500 bar.py represents an API with the following endpoints: / /baz /foo /foo/bar","title":"Receiving requests"},{"location":"Tutorial/requests/#receiving-requests","text":"Perhaps the most important part of any API is the ability to receive requests and carry out a certain function based on the characteristics of this request. For a simple REST API, at a high level, two things define what happens to a request. Need a refresher on HTTP methods? Check out this resource The request endpoint The HTTP request method Sirius has ways to manage both of these with such ease. It seems logical to begin with endpoints, since HTTP methods form a subset of operations upon each endpoint.","title":"Receiving requests"},{"location":"Tutorial/requests/#endpoints","text":"An endpoint in a Sirius API is represented by a Python file in a certain directory. By default this magical directory is src/routes . The following directory structure: src/ \u2514\u2500 routes/ \u251c\u2500 __init__.py \u251c\u2500 baz.py \u2514\u2500 foo/ \u251c\u2500 __init__.py \u2514\u2500 bar.py represents an API with the following endpoints: / /baz /foo /foo/bar","title":"Endpoints"}]}